# 进程(multiprocessing) [ˌmʌltɪˈprəʊsɛsɪŋ] 
## 概念
* ⼀个正在运⾏的程序或者软件就是⼀个进程，它是操作系统进⾏资源分配的基本单位，也就是说每启动⼀个进程，操作系统都会给其分配⼀定的运⾏资源(内存资源)保证进程的运⾏
* ⼀个程序运⾏后⾄少有⼀个进程，⼀个进程默认有⼀个线程，进程⾥⾯可以创建多个线程，线程是依附在进程⾥⾯的，没有进程就没有线程
* 进程是操作系统进⾏资源分配的基本单位
## 多进程的使用
### 进程类说明
#### Process([group [, target [, name [, args [, kwargs] ] ] ] ])
* group：指定进程组，⽬前只能使⽤None
* target：执⾏的⽬标任务名
* name：进程名字
* args：以元组⽅式给执⾏任务传参
* kwargs：以字典⽅式给执⾏任务传参
#### Process创建的实例对象的常⽤⽅法
* start()：启动⼦进程实例（创建⼦进程）
* is_alive()：判断进程子进程是否还在活着 return T/F
* join()：等待⼦进程执⾏结束
* terminate()：不管任务是否完成，⽴即终⽌⼦进程
#### Process创建的实例对象的常⽤属性
* name：当前进程的别名，默认为Process-N，N为从1开始递增的整数
* pid：当前进程的pid（进程号）
```python
# 导入进程包
import multiprocessing
import time

# 进程1
def process_01():
    for i in range(5):
        print("进程01")
        time.sleep(0.2)

# 进程2
def process_02():
    for i in range(5):
        print("进程02")
        time.sleep(0.2)

if __name__ == "__main__":
    # 创建跳舞的⼦进程
    # group: 表示进程组，⽬前只能使⽤None
    # target: 表示执⾏的⽬标任务名(函数名、⽅法名)
    # name: 进程名称, 默认是Process-1, .....
    process_1 = multiprocessing.Process(target=process_01, name="myprocess")
    process_2 = multiprocessing.Process(target=process_02)
    process_1.start()
    process_2.start()
```
### 获取进程号
* 获取进程编号的⽬的是验证主进程和⼦进程的关系，可以得知⼦进程是由那个主进程创建出来的
#### 获取进程号操作
* os.getpid() 获取当前进程编号  
* os.getppid() 获取当前⽗进程编号  
* multiprocessing.current_process() 获取当前进程
* os.kill(进程编号, 9) 杀掉进程
```python
# 导入进程包
import multiprocessing
import time
import os

# 进程1
def process_01():
    # 获取当前子进程
    print("子进程1:", os.getpid())
    # 获取父进程
    print("父进程1:", os.getppid())
    for i in range(5):
        time.sleep(0.2)   
        #杀掉当前进程
        os.kill(os.getpid(), 9)

# 进程2
def process_02():
    # 获取当前子进程
    print("子进程2:", os.getpid())
    # 获取父进程
    print("父进程2:", os.getppid())
    for i in range(5):
        time.sleep(0.2)
        # 杀掉当前进程
        os.kill(os.getpid(), 9)


if __name__ == "__main__":
    print("mian的父进程", os.getppid())
    print("mian的子进程", os.getpid())
    # 创建跳舞的⼦进程
    # group: 表示进程组，⽬前只能使⽤None
    # target: 表示执⾏的⽬标任务名(函数名、⽅法名)
    # name: 进程名称, 默认是Process-1, .....
    process_1 = multiprocessing.Process(target=process_01, name="myprocess")
    process_2 = multiprocessing.Process(target=process_02)
    process_1.start()
    process_2.start()
```
### 进程带参数
#### Process类执⾏任务并给任务传参数有两种⽅式
* 元组⽅式传参(args): 元组⽅式传参⼀定要和参数的顺序保持⼀致
* 字典⽅式传参(kwargs): 字典⽅式传参字典中的key⼀定要和参数名保持⼀致
```python
import multiprocessing
# 进程1
# 参数：data
def process_01(data):
    print(data)
# 进程2
# 参数：data
def process_02(data):
    print(data)
if __name__ == "__main__":
    # 创建跳舞的⼦进程
    # group: 表示进程组，⽬前只能使⽤None
    # target: 表示执⾏的⽬标任务名(函数名、⽅法名)
    # name: 进程名称, 默认是Process-1, .....
    process_1 = multiprocessing.Process(target=process_01, name="myprocess", args=("我是进程1",))
    # 参数args 必须传入元祖 tuple
    process_2 = multiprocessing.Process(target=process_02, kwargs={"data": "我是进程2"})
    # 参数kwargs 必须传入字典 dict
    process_1.start()
    process_2.start()
```
### 进程注意事项
* 进程之间不共享全局变量
```python
import multiprocessing
# 进程1
list1=[] # 主进程变量  list1
def process_01():
    for i in range(5):
        list1.append(i)
    print("进程1 list1:", list1)

# 进程2
def process_02():
    print("去取list1:", list1)
if __name__ == "__main__":
    # 创建跳舞的⼦进程
    # group: 表示进程组，⽬前只能使⽤None
    # target: 表示执⾏的⽬标任务名(函数名、⽅法名)
    # name: 进程名称, 默认是Process-1, .....
    process_1 = multiprocessing.Process(target=process_01, name="myprocess",)
    # 参数args 必须传入元祖 tuple
    process_2 = multiprocessing.Process(target=process_02, )
    # 参数kwargs 必须传入字典 dict
    process_1.start()
    process_2.start()
# 进程1 list1: [0, 1, 2, 3, 4]
# 取list1: []  全局变量不共享
```
* 主进程会等待所以子进程结束后再结束 
* 
```python
import time
import multiprocessing
def process_01():
    nums = 0
    for i in range(10):
        nums += 0.2
        print(nums.__round__(2))
        time.sleep(0.2)
    # 子进程2s结束

if __name__ == "__main__":
    # 创建跳舞的⼦进程
    # group: 表示进程组，⽬前只能使⽤None
    # target: 表示执⾏的⽬标任务名(函数名、⽅法名)
    # name: 进程名称, 默认是Process-1, .....
    process_1 = multiprocessing.Process(target=process_01, name="myprocess",)
    process_1.start()
    time.sleep(0.5)
    # 主进程0.5s结束
    print("over")
    exit()
# 0.2
# 0.4
# over
# 0.6
# 0.8 
# ...
# 主进程等待子进程结束后再结束
```
### 守护进程
#### 目的:当主进程销毁时，子进程也跟着销毁
* 设置守护主进程⽅式(在进程开始之前):⼦进程对象.daemon = True 守护主进程就是主进程退出，⼦进程销毁不再执⾏，⼦进程的⽣命周期依赖与主进程
* 销毁⼦进程⽅式:⼦进程对象.terminate() 
```python
import time
import multiprocessing
def process_01():
    nums = 0
    for i in range(10):
        nums += 0.2
        print(nums.__round__(2))
        time.sleep(0.2)
    # 子进程2s结束

if __name__ == "__main__":
    # 创建跳舞的⼦进程
    # group: 表示进程组，⽬前只能使⽤None
    # target: 表示执⾏的⽬标任务名(函数名、⽅法名)
    # name: 进程名称, 默认是Process-1, .....
    process_1 = multiprocessing.Process(target=process_01, name="myprocess",)
    process_1.daemon = True
    # 设置守护主进程，主进程退出⼦进程直接销毁，⼦进程的⽣命周期依赖与主进程
    # 设置在子进程开始前
    process_1.start()
    time.sleep(0.5)
    # 主进程0.5s结束
    print("over")
    # is_alive() 判断子进程是否存活
    if process_1.is_alive():
        process_1.terminate()
    # 销毁子进程
    exit()
    # 退出主进程
# 0.2
# 0.4
# over

```
